#!/usr/bin/env bash

CFG_FILE="~/.jrnl2.rc"
# parent tag included for all time-tracking entries
TIME_TRACK_TAG="@time-track" 
# If non-blank, use this journal for all time-tracking, instead of the default
TIME_TRACK_JOURNAL=""
MAIN_JOURNAL="$HOME/journals/journal.txt"
TAG_COLOR="00;36" 

#GREP_COLORS="mt=00;34" grep --color=always 'two\|$'
#GREP_COLORS="mt=00;34" grep --color=always -e '' -e 'two'

# If exists, reads the above configuration from the external config
[[ -f "$CFG_FILE" ]] && . "$CFG_FILE"

COMMANDS=()
OPTIONS=()
declare -A ARGS=()
SEARCH_ARGS=()

# TODO journal edit and delete operations (within search range)
# TODO entry with custom date
# TODO entry/search in custom journal

function jrnl_time_start
{
    $(jrnl $TIME_TRACK_JOURNAL $TIME_TRACK_TAG -n 1 --short | grep -q '@.*start') &&\
        echo "Time already running" && return
    if [[ $1 ]] ; then
        tag=$1
    else
        options=$(jrnl --tags $TIME_TRACK_JOURNAL $TIME_TRACK_TAG | grep -v $TIME_TRACK_TAG | awk '{print $1}')
        tag=$(echo -e "$options" | dmenu -i -p "Select or type a new task preceded with @")
    fi
    [ -z "$tag" ] && echo "Aborted" && return
    jrnl $TIME_TRACK_JOURNAL $TIME_TRACK_TAG $tag start
    msg="Tracking time for $TIME_TRACK_TAG $tag"
    echo "$msg"
    notify-send -t 5000 "$msg"
}

function jrnl_time_end
{
    output=$(jrnl $TIME_TRACK_JOURNAL $TIME_TRACK_TAG -n 1 --short | grep '@.*start')
    [ -z "$output" ] && echo "No time currently tracked" && return
    relevant_tags=$(jrnl --tags $TIME_TRACK_JOURNAL $TIME_TRACK_TAG -n 1 | awk '{print $1}' | xargs echo)
    jrnl $TIME_TRACK_JOURNAL $relevant_tags end
    msg="End time for $relevant_tags"
    echo "$msg"
    notify-send -t 5000 "$msg"
}

function jrnl_report_time
{
    (($# < 1)) && echo -e "Can pass additional *conjunctive* jrnl parameters. Ex: \"-to/-from DATE\", or specific tag.\n"
    output=$(jrnl --tags -and $TIME_TRACK_JOURNAL $* $TIME_TRACK_TAG)
    grep -q 'No tags found' <<< $output && \
        echo "No relevant time-tracking tags found" && return
    awk '{print $1}' <<< $output |\
    while read -r tag ; do
        printf '%20s: ' "$tag";
        jrnl -and $TIME_TRACK_JOURNAL $* $TIME_TRACK_TAG $tag --short |\
        dategrep '>2018-01-01' -o |\
        while read -r start_time && read -r end_time ; do 
            datediff -f "%Hh%Mm" "$start_time" "$end_time" 
        done |\
        xargs dateadd '2018-01-00 00:00' -f "%dd %Hh %Mm"
    done
}

# Imports file into jrnl with the respective last-modification date
function jrnl_entry_import 
{
    (($# < 1)) && echo "Provide a filename to import" && return
    (date -r $1 '+%Y-%m-%d %H:%M: ' && cat "$1") | jrnl

}

# Pass disjunctive arguments in regex (ie 'pat1|pat2' or '@(tag1|tag2)'
# Pass conjunctive arguments as separate search -s operations, which are passed as separate arguments here
    # awk '/foo/ && /bar/'
    # grep -P '(?=.*?word1)(?=.*?word2)(?=.*?word3)^.*$'
# max_entries works by doing a 'short' | tail -n | head -1 and finding the initial timestamp. Then redo the record search starting from that timestamp.
# TODO: date search (on, before, after, last week, last 7 days, ...)
    # Resolve partially via plain regex search on the date fields 
        # ie '^2018-(0[7-9]|10)' for July-October of 2018
# TODO: for edit, save the first lines of searched/edited entries
    # Once editing session complete, iterate through all entries:
        # replace original entry with the edited, or with blank if absent in editing session
function jrnl_entry_search
{
    max_entries=0
    [[ "${OPTIONS[*]}" =~ short ]] && instr='P' || instr='p'
    [[ "${OPTIONS[*]}" =~ max_entries ]] && max_entries=${ARGS['max_entries']}
    [[ "${OPTIONS[*]}" =~ edit ]] && edit=1
    record_start_pat='^[0-9]{4}-[0-9]{2}-[0-9]{2}'
    # case-insensitive match
    # TODO: The last-line entry fails to match if it's a one-liner. Could place a blank line at end always.
    search_cmd='sed -nr "/'$record_start_pat'/{x;/./I$instr;d}; \${x;G;/./I$instr}; {H}"'
    while [[ -n $1 ]]; do
        pattern=$1
        search_cmd=$(sed -r 's/([^\/]*\$instr)/{\/'"$pattern"'\/\1}/g' <<< "$search_cmd")
        shift
    done
    [[ -n $TAG_COLOR ]] && search_cmd_suf=" |GREP_COLORS='mt=$TAG_COLOR' grep --color -e '' -e '@\w\+'"
    if [[ -n "$edit" ]]; then
        tmpfile=$(mktemp --tmpdir jrnl-edit.XXXXXX)
        trap 'rm "$tmpfile"' 0 1 15
        search_cmd_suf=" > $tmpfile"
    fi
    if [[ $max_entries -gt 0 ]]; then
        prev_instr=$instr
        instr='P'
        # Use the start line, forward shell escaped, verbatim as the start search space
        start_line=$(eval "$search_cmd $MAIN_JOURNAL | tail -$max_entries | head -1" | sed 's/\//\\\//g')
        instr=$prev_instr
        sed -n "/$start_line/,\$p" "$MAIN_JOURNAL" | eval "$search_cmd $search_cmd_suf" 
    else
        eval "$search_cmd $MAIN_JOURNAL $search_cmd_suf"
    fi
#   if [[ -n "$edit" ]]; then
#       entry_headers=$(sed "$record_start_pat" $tmpfile)
#       $EDITOR $tmpfile
#       num_edited=0
#       num_deleted=0
#       while read -r line; do
#           grep -qF "$line" $tmpfile && (( num_edited++ )) || (( num_deleted++ ))
#           new_record=$(sed -nr "/$record_start_pat/{x;/$line/{p;d;q}; {H;d}" $tmpfile)
##           search_cmd='sed -nr "/'$record_start_pat'/{x;//$instr;d}; {H;d}"'
#           #sed -ir "/$line/,/$record_start_pat/{H;{x;/$line/{d;" $MAIN_JOURNAL
#       done <<< "$entry_headers"
#       #edited=$(cat $tmpfile)
#       [[ $num_edited -gt 0 ]] && echo "edited $num_edited entries"
#       [[ $num_deleted -gt 0 ]] && echo "deleted $num_deleted entries"
#   fi
}

# Adds entry in preference of
# 1. stdin
# 2. argument
# 3. Edited in $EDITOR
function jrnl_entry_add
{
    # First, try stdin
    entry=$(
        while read -rt .01 stdin; do
            echo "$stdin"
        done
    )
    if [[ -z "$entry" ]]; then
        if [[ -n $1 ]]; then 
            entry="${@:1}"
        else
            # TODO: how to wait for $EDITOR to truly exit?
            tmpfile=$(mktemp --tmpdir jrnl-new.XXXXXX)
            trap 'rm "$tmpfile"' 0 1 15
            $EDITOR $tmpfile
            entry=$(cat $tmpfile)
            #rm $tmpfile
        fi
    fi
    if [[ -n "$entry" ]]; then
        filter='1s/\.\s\+/.\n/' # Separate the first sentence from rest by a NL.
        echo -e "\n$(date '+%Y-%m-%d %H:%M') $(sed "$filter" <<< "$entry")" >> "$MAIN_JOURNAL"
        echo "1 new entry written"
    else 
        echo "Journal unmodified"
    fi
}

#
## The stdout isn't immediately visible with each selected <ctrl>+<enter> tag as the entire output is piped to echo
#alias jrnl_select_tags="jrnl --tags | awk '{print \$1}' | dmenu | xargs echo"

function usage {
  cat <<EOF  
Need to provide a command or alias.
    -h|--help: help text,
    -n|--max entries <n>: limit query to the last n entries,
    -s|--search <pattern>: search for records containing <pattern>,
    -e|--edit: edit the searched entries
    -t|--tags: view list of tags
    --short: view entry headings only
    --time_start: start timetracking a task
    --time_end: stop timetracking
    --time_report: report on all timetracking
EOF
}

function parseargs() {
    while [[ -n $1 ]]; do
        args_needed=false
        is_opt=false
        case $1 in
            # Switches and configuration
            -t|--tags) COMMANDS+=('tags');;
            --short) OPTIONS+=('short');;
            -s|--search) 
                args_needed=true
                is_opt=false
                cmd="search"
                ;;
            -e|--edit) OPTIONS+=('edit');;
            -n|--max_entries) 
                args_needed=true
                is_opt=true
                cmd="max_entries"
                ;;
            --time_start) COMMANDS+=("time_start");;
            --time_end) COMMANDS+=("time_end");;
            --time_report) COMMANDS+=("time_report");;
            -h|--help|-*) COMMANDS+=('help');;
            *) return;; 
        esac
        shift
        if $args_needed; then
            [[ $# -lt 1 || $1 =~ ^\- ]] && echo "$cmd needs an argument" && exit 128
            $is_opt && OPTIONS+=("$cmd") || COMMANDS+=("$cmd")
            [[ "$cmd" == "search" ]] && SEARCH_ARGS+=("$1") || ARGS["$cmd"]="$1" 
            shift
        fi
    done
}

parseargs "$@"

if [[ ${#COMMANDS} == 0 ]]; then
    # if restrictive options present, filter on the entire journal
    [[ ${#OPTIONS} == 0 ]] && jrnl_entry_add "$@" || jrnl_entry_search
    exit 0
fi

case ${COMMANDS[0]} in
    search) jrnl_entry_search  "${SEARCH_ARGS[@]}";;
    tags) grep -o '@\w\+' $MAIN_JOURNAL | sort | uniq -ci | sort -nr;;
    time_start) jrnl_time_start;;
    time_end) jrnl_time_end;;
    time_report) jrnl_report_time;;
    help) usage;;
esac
