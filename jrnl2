#!/bin/bash

CFG_FILE="$HOME/.jrnl2.rc"
# parent tag included for all time-tracking entries
TIME_TRACK_TAG="@time-track" 
# If non-blank, use this journal for all time-tracking, instead of the default
TIME_TRACK_JOURNAL=""
#TAG_COLOR="00;36" 
RECORD_START_PAT='[0-9]{4}-[0-9]{2}-[0-9]{2}\s[0-9]{2}:[0-9]{2}'

declare -A JOURNALS=(
    ['default']="$HOME/journals/journal.txt"
)

# If exists, reads the above configuration from the external config
[[ -f "$CFG_FILE" ]] && . "$CFG_FILE"

JOURNAL="${JOURNALS['default']}"

COMMANDS=()
OPTIONS=()
declare -A ARGS=()
SEARCH_ARGS=()

# TODO: update time tracking functions to work with jrnl2
# TODO journal edit and delete operations (within search range)
	# save the first lines of searched/edited entries
		# Once editing session complete, iterate through all entries:
			# replace original entry with the edited, or with blank if absent in editing session
	# alternatively, remove original entries, insert the new ones, or whatever left of them
# TODO: date search (on, before, after, last week, last 7 days, ...)
    # Resolve partially via plain regex search on the date fields 
        # ie '^2018-(0[7-9]|10)' for July-October of 2018
# TODO entry with custom date

function jrnl_time_start
{
    $(jrnl $TIME_TRACK_JOURNAL $TIME_TRACK_TAG -n 1 --short | grep -q '@.*start') &&\
        echo "Time already running" && return
    if [[ $1 ]] ; then
        tag=$1
    else
        options=$(jrnl $TIME_TRACK_JOURNAL --tags $TIME_TRACK_TAG | grep -v $TIME_TRACK_TAG | awk '{print $1}')
        tag=$(echo -e "$options" | dmenu -i -p "Select or type a new task preceded with @")
    fi
    [ -z "$tag" ] && echo "Aborted" && return
    jrnl $TIME_TRACK_JOURNAL $TIME_TRACK_TAG $tag start
    msg="Tracking time for $TIME_TRACK_TAG $tag"
    echo "$msg"
    notify-send -t 5000 "$msg"
}

function jrnl_time_end
{
    output=$(jrnl $TIME_TRACK_JOURNAL $TIME_TRACK_TAG -n 1 --short | grep '@.*start')
    [ -z "$output" ] && echo "No time currently tracked" && return
    relevant_tags=$(jrnl --tags $TIME_TRACK_JOURNAL $TIME_TRACK_TAG -n 1 | awk '{print $1}' | xargs echo)
    jrnl $TIME_TRACK_JOURNAL $relevant_tags end
    msg="End time for $relevant_tags"
    echo "$msg"
    notify-send -t 5000 "$msg"
}

function jrnl_report_time
{
    (($# < 1)) && echo -e "Can pass additional *conjunctive* jrnl parameters. Ex: \"-to/-from DATE\", or specific tag.\n"
    output=$(jrnl --tags -and $TIME_TRACK_JOURNAL $* $TIME_TRACK_TAG)
    grep -q 'No tags found' <<< $output && \
        echo "No relevant time-tracking tags found" && return
    awk '{print $1}' <<< $output |\
    while read -r tag ; do
        printf '%20s: ' "$tag";
        jrnl -and $TIME_TRACK_JOURNAL $* $TIME_TRACK_TAG $tag --short |\
        dategrep '>2018-01-01' -o |\
        while read -r start_time && read -r end_time ; do 
            datediff -f "%Hh%Mm" "$start_time" "$end_time" 
        done |\
        xargs dateadd '2018-01-00 00:00' -f "%dd %Hh %Mm"
    done
}

# Imports file into jrnl with the respective last-modification date
function jrnl_entry_import 
{
    (($# < 1)) && echo "Provide a filename to import" && return
    (date -r $1 '+%Y-%m-%d %H:%M: ' && cat "$1") | jrnl

}

# Pass disjunctive arguments in regex (ie 'pat1|pat2' or '@(tag1|tag2)'
# Pass conjunctive arguments as separate search -s operations, which are passed as separate arguments here
    # awk '/foo/ && /bar/'
    # grep -P '(?=.*?word1)(?=.*?word2)(?=.*?word3)^.*$'
function jrnl_entry_search
{
    short_srch="$1"; shift
    max_entries="$1"; shift

    $short_srch && instr='P' || instr='p'
    # case-insensitive match
    # TODO: The last-line entry fails to match if it's a one-liner without a following newline. Presently place a new line "after" each entry.
    search_cmd='sed -nr "/^'$RECORD_START_PAT'/{x;/./$instr;d; \${x;/./$instr;d}}; \${x;G;/./$instr}; {H}"'
    while [[ -n $1 ]]; do
        pattern=$1
        search_cmd=$(sed -r 's/(\$instr)/{\/'"$pattern"'\/I\1}/g' <<< "$search_cmd")
        shift
    done
	if [[ -n $TAG_COLOR ]]; then
		cmd_suffix=" | GREP_COLORS='mt=$TAG_COLOR' grep --color -e '' -e '@\w\+'"
    fi
	if [[ $max_entries -gt 0 ]]; then
        prev_instr=$instr
        # Output entries in --short (1-line) mode to establish the start entry for the search space
        instr='P' 
        start_line=$(eval "$search_cmd $JOURNAL | tail -$max_entries | head -1" | egrep -o "^$RECORD_START_PAT")
        instr=$prev_instr
		sed -n "/$start_line/,\$p" "$JOURNAL" | eval "$search_cmd $cmd_suffix" 
    else
        eval "$search_cmd $JOURNAL $cmd_suffix"
    fi
}

function jrnl_entry_edit
{
    max_entries="$1"; shift
    [ -z "$max_entries" ] && max_entries=0
    tmpfile=$(mktemp --tmpdir jrnl-edit.XXXXXX)
    trap 'rm "$tmpfile"' 0 1 15
    jrnl_entry_search false $max_entries "$@" > "$tmpfile"

    sed -i -r 's/^'"$RECORD_START_PAT"'/==\0 MODIFY\/DELETE RECORD BELOW. DO NOT DELETE THIS LINE.==\n\n\0/' $tmpfile
    $EDITOR $tmpfile
    num_edited=0
    num_deleted=0
    num_intact=0
    timestamps=$(sed -nr "s/^==($RECORD_START_PAT).*/\1/p" $tmpfile)
    while read -r tstamp; do
        old_record=$(jrnl_entry_search false 1 "^$tstamp")
        new_record=$(sed -rn "/^==$tstamp/,/^==/{//!p}" "$tmpfile" | sed -r '0,/^\s*$/{/^\s*$/d}')
        if [ ! "$old_record" = "$new_record" ]; then
            if [ -n "$new_record" ]; then
                tmpjrnl=$(mktemp --tmpdir jrnl-temp.XXXXXX)
				trap 'rm "$tmpfile"' 0 1 15
                (
					sed -rn '/^'"$tstamp"'/,$!p' $JOURNAL
					echo -e "$new_record""\n"
					sed -r "1,/^$tstamp/d" $JOURNAL |
						sed -rn "/^$RECORD_START_PAT"'/,$p'
                ) | tee "$tmpjrnl"
                #mv "$tmpjrnl" "$JOURNAL"
                (( num_edited++ ))
            else # delete old record
                sed -i -nr "/^$tstamp/,/$RECORD_START_PAT/{//!d;/^$tstamp/d};p" $JOURNAL
                (( num_deleted++ ))
            fi
        else
            (( num_intact++ ))
        fi
    done <<< "$timestamps"
    [[ $num_edited -gt 0 ]] && echo "Edited $num_edited entries"
    [[ $num_deleted -gt 0 ]] && echo "Deleted $num_deleted entries"
    [[ $num_intact -gt 0 ]] && echo "Intact $num_intact entries"
}

# Adds entry in preference of
# 1. stdin
# 2. argument
# 3. Edited in $EDITOR
function jrnl_entry_add
{
    # First, try stdin
    entry=$(
        while read -rt .01 stdin; do
            echo "$stdin"
        done
    )
    if [[ -z "$entry" ]]; then
        if [[ -n $1 ]]; then 
            entry="${@:1}"
        else
            tmpfile=$(mktemp --tmpdir jrnl-new.XXXXXX)
            trap 'rm "$tmpfile"' 0 1 15
            $EDITOR $tmpfile
            entry=$(cat $tmpfile)
            #rm $tmpfile
        fi
    fi
    if [[ -n "$entry" ]]; then
        filter='1s/\.\s\+/.\n/' # Separate the first sentence from rest by a NL.
		[[ ! "$entry" =~ "$RECORD_START_PAT" ]] && 
			prefix="$(date '+%Y-%m-%d %H:%M') " || prefix=""
        echo -e "$prefix""$(sed "$filter" <<< "$entry")\n" >> "$JOURNAL"
        echo "1 new entry written"
    else 
        echo "Journal unmodified"
    fi
}

# List all tags within provided journal file or otherwise stdin
function list_tags {
	[[ -n $1 ]] && input="$1" || input="-"
    egrep -o '(^|\s)@[_[:alnum:]\-]+' "$input" | sed 's/^\s*//' |  sort -ib | uniq -ci | sort -nr
}

#
## The stdout isn't immediately visible with each selected <ctrl>+<enter> tag as the entire output is piped to echo
#alias jrnl_select_tags="jrnl --tags | awk '{print \$1}' | dmenu | xargs echo"

function usage {
  cat <<EOF  
Need to provide a command or alias.
    -h|--help: help text,
    -n|--max entries <n>: limit query to the last n entries,
    -s|--search <pattern>: search for records containing <pattern>,
    -e|--edit: edit the searched entries
    -t|--tags: view list of tags
    -ls|--list: list all available journals
    --short: view entry headings only
    --time_start: start timetracking a task
    --time_end: stop timetracking
    --time_report: report on all timetracking
EOF
}

function parseargs() {
    while [[ -n $1 ]]; do
        args_needed=false
        is_opt=false
        case $1 in
            # Switches and configuration
            -t|--tags) COMMANDS+=('tags');;
			-ls|--ls|--list) COMMANDS+=('ls');;
            --short) OPTIONS+=('short');;
            -s|--search) 
                args_needed=true
                is_opt=false
                cmd="search"
                ;;
            -e|--edit) OPTIONS+=('edit');;
            -n|--max_entries) 
                args_needed=true
                is_opt=true
                cmd="max_entries"
                ;;
            --time_start) COMMANDS+=("time_start");;
            --time_end) COMMANDS+=("time_end");;
            --time_report) COMMANDS+=("time_report");;
            -h|--help|-*) COMMANDS+=('help');;
            *) return;; 
        esac
        shift
        if $args_needed; then
            [[ $# -lt 1 || $1 =~ ^\- ]] && echo "$cmd needs an argument" && exit 128
            $is_opt && OPTIONS+=("$cmd") || COMMANDS+=("$cmd")
            [[ "$cmd" == "search" ]] && SEARCH_ARGS+=("$1") || ARGS["$cmd"]="$1" 
            shift
        fi
    done
}

# Select an alternate journal as the first argument only
if [[ -n "$1" && -n "${JOURNALS[$1]}" ]]; then
	JOURNAL="${JOURNALS[$1]}" 
	shift
fi

parseargs "$@"

if [[ ${#COMMANDS} == 0 ]]; then
    # if restrictive options present, filter on the entire journal
    if [[ ${#OPTIONS} == 0 ]]; then 
        jrnl_entry_add "$@"
        exit 0
    fi
    COMMANDS+=("search")
fi

case ${COMMANDS[0]} in
    search) 
        [[ "${OPTIONS[*]}" =~ short ]] && short_srch=true || short_srch=false
        [[ "${OPTIONS[*]}" =~ max_entries ]] && 
            max_entries=${ARGS['max_entries']} || max_entries=0
        if [[ "${OPTIONS[*]}" =~ edit ]]; then 
			jrnl_entry_edit $max_entries "${SEARCH_ARGS[@]}"
		else
			jrnl_entry_search $short_srch $max_entries "${SEARCH_ARGS[@]}"
		fi
		;;
	ls) for j in "${!JOURNALS[@]}"; do echo "$j"; done;;
    tags) list_tags "$JOURNAL";;
    time_start) jrnl_time_start;;
    time_end) jrnl_time_end;;
    time_report) jrnl_report_time;;
    help) usage;;
esac
